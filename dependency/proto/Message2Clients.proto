//Message2Clients
syntax = "proto3";
package Protobuf;
option csharp_namespace = "Communication.Proto";

import "MessageType.proto";

/*---------------------------------2021-10-1重写.proto---------------------------------------*/

message ChangeableCharacterProperty
{
    int64 x = 1;
    int64 y = 2;
    int64 attack = 3;
    double timeUntilAttack = 4;
    int64 speed = 5;
    int64 life = 6;
    double timeUntilSkillOne = 7;
    double timeUntilSkillTwo = 8;
    int64 gemNum = 9;
    BuffType buff = 10;
    PropType prop = 11;
    PlaceType place = 12;
}

message BasicalCharacterProperty
{
    int64 guid = 1;     //操作方法：Client和Server互相约定guid。非负整数中，1-8这8个guid预留给8个人物，其余在子弹或道具被创造/破坏时分发和回收。Client端用向量[guid]储存物体信息和对应的控件实例。
                        //0号guid存储单播模式中每人Client对应的GUID。
    int64 PassiveSkillType = 2;
    int64 ActiveSkillType = 3;
}

message MessageOfProp
{
    PropType type = 1;
    int64 x = 2;
    int64 y = 3;
}

message MessageOfBullet
{
    BulletType type = 1;
    int64 bap = 2;
    int64 boomRange = 3;
}

message MessageToInitialize
{
    int64 MapSerial = 1;
    int64 NumberOfValidPlayer = 2;
    repeated BasicalCharacterProperty property = 3;
}
//全设成int64了，麻烦逻辑组其他二位指正
message MessageToAddInstance
{
    GameObjType instanceType= 1; //这里逻辑上只能写道具和子弹,Client也只准备了这两个实例的创建函数。
                                 //人物在开始时通过BasicalVharacterProperty中的信息添加，无法手动添加。如果需要有添加草丛的操作，请联系我。
    int64 guid = 2;            //要分配的guid。为防止重复分配，建议Server也写一个对应的vector。
    oneof messageOfInstance    //根据instanceType决定消息类型
    {
        MessageOfProp messageOfProp= 3;
        MessageOfBullet messageOfBullet= 4;
    }
}

message MessageToDestroyInstance
{
    int64 guid;
}
//拿到要销毁物体的guid后，Client端vector释放掉该guid位置的物体信息，并置为null回收该地址，同时删除该物品的对应控件句柄。
//人物的guid无法被回收，死亡时颜色变为透明。任何试图将guid1-8删除的操作应被认定为非法。
//子弹被销毁的同时会显示一个爆炸效果。饼：画圆
message MessageToOperate
{
    int32 operateKind = 1;
    oneof messageOfOperation
    {
        MessageToAddInstance messageToAddInstance= 2;
        MessageToDestroyInstance messageToDestroyInstance = 3;
    }
}
//操作指令
message MessageToRefresh
{
    GameObjType gameObjType = 1;
    oneof gameObjMessage
    {
        MessageOfBullet messageOfBullet = 2;
        ChangeableCharacterProperty messageOfCharacter = 3;
    }
}//这个函数只包含了用于刷新人物的部分。在Client端，当接到这个消息后，Client会将消息内的人物信息存入vector，并将vector中的所有信息读入屏幕显示。
//更改之后，Client读取信息的逻辑和THUAI4不同了，现在是用proto信息将游戏信息读入缓存，定时从缓存刷新屏幕。
//采用这个方法是因为我比较菜，缓存法容易维护，如果有更好的方法也可以更改。

message MessageToOneClient
{
    int64 playerID = 1;			//指明发送给谁
    int64 teamID = 2;			//指明发送给谁
    
    MessageType messageType = 3;
    int64 guid = 4;             //自己的guid
    string message = 5;         //如果 messageType 为 Send，则为要发送的消息
} //继承自THUIAI4
//注：转换函数还没写好